// ---------- lightweight utilities ----------
const $ = sel => document.querySelector(sel);
const chat = $('#chatbox');
const logWin = $('#log-window');
const input = $('#user-input');
const form = $('#chat-form');
const sendBtn = $('#send-btn');
const Bot = 'Jolene';
const bot = 'Jolene (Computer)';

// Logging
function log(msg) {
  const line = document.createElement('div');
  line.textContent = msg;
  logWin.appendChild(line);
  logWin.scrollTop = logWin.scrollHeight;
}

// Add a chat bubble
function addMsg(sender, text) {
  const div = document.createElement('div');
  div.className = `msg ${sender === 'You' ? 'me' : 'bot'}`;
  div.innerHTML = escapeHTML(text);
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
}

// Escape HTML
const escapeHTML = s => {
  if (typeof s !== 'string') return '';
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
};

// ---------- compromise (NLP library) ----------
const nlp = (typeof window !== 'undefined' && window.__nlp) ? window.__nlp : (() => { 
  // graceful no-op fallback if compromise failed to load
  const f = x => ({ people:()=>({out:()=>[]}), places:()=>({out:()=>[]}), match:()=>({out:()=>[]}) });
  return (/* str */) => f();
})();

// ---------- minimal sentiment (fallback if search yields nothing) ----------
const POS = new Set(['good','great','awesome','amazing','love','nice','happy','glad']);
const NEG = new Set(['bad','sad','angry','horrible','upset','frustrating','annoyed']);
function getSentiment(s) {
  const toks = s.toLowerCase().split(/\W+/);
  let p = 0, n = 0;
  toks.forEach(t => { if (POS.has(t)) p++; if (NEG.has(t)) n++; });
  return p > n ? 'positive' : n > p ? 'negative' : 'neutral';
}

// ---------- lazy PDF extraction (unchanged) ----------
const pdfLibPromise = (async () => {
  const mod = await import('./libs/pdfjs-5.4.149-dist/build/pdf.mjs');
  mod.GlobalWorkerOptions.workerSrc = './libs/pdfjs-5.4.149-dist/build/pdf.worker.mjs';
  return mod;
})();

async function extractPDFTextOnce(pdfPath, pageLimit = 3) {
  const pdfjs = await pdfLibPromise;
  const doc = await pdfjs.getDocument(pdfPath).promise;
  const max = Math.min(doc.numPages, pageLimit);
  let text = '';
  for (let i = 1; i <= max; i++) {
    const page = await doc.getPage(i);
    const tc = await page.getTextContent();
    text += tc.items.map(it => it.str).join(' ') + ' ';
  }
  return text;
}

const pdfCache = new Map();
async function getPdfSnippet(which, chars = 600) {
  const paths = {
    pride: './assets/PP_Austen_PD_1.pdf',
    devlin: './assets/HowtoSpeakWrite_Devlin_PD_1.pdf',
    jimmie: './assets/AdvnturesJimmieDale_Packard_PD_1.pdf'
  };
  const path = paths[which];
  if (!path) return null;

  if (!pdfCache.has(path)) {
    log(`PDF load on demand: ${path}`);
    const text = await extractPDFTextOnce(path, 4);
    pdfCache.set(path, text);
  }
  const full = pdfCache.get(path) || '';
  return full.slice(0, chars);
}

// ---------- KJV/Strongs search via Web Worker ----------
const kjvWorker = new Worker('workers/kjv_worker.js', { type: 'module' });
//const kjvWorker = new Worker('./kjv_worker.js');

// IMPORTANT: single render path (no global onmessage).
// Every query registers its own temporary listener and then removes it.

let qCounter = 0;
function searchKJVStream(query, opts = { limit: 5, phrase: false }) {
  return new Promise((resolve, reject) => {
    const qid = ++qCounter;
    const onResult = (e) => {
      const { kind, qid: rid, results, error } = e.data || {};
      if (rid !== qid) return;              // ignore other replies
      kjvWorker.removeEventListener('message', onResult);
      if (kind === 'kjv:done') return resolve(results || []);
      return reject(new Error(error || 'Unknown worker error'));
    };
    kjvWorker.addEventListener('message', onResult);
    kjvWorker.postMessage({ kind: 'kjv:search', qid, query, opts });
  });
}

// Unified formatter: accepts {reference,snippet} OR {book,chapter,verse,text}
function formatKJV(items, title) {
  const lines = items.map(it => {
    const reference = it.id || it.reference
      || (it.book ? `${it.book} ${it.chapter}:${it.verse}` : 'No reference');

    const raw = it.snippet || it.text || '';
    // Strip Strong’s {H####}/{G####} and parser tags like {(H####)}
    const snippet = raw.replace(/{[HG]\d+}|\{\([A-Z]\d+\)\}/g, '').trim();
    return `• ${escapeHTML(reference)} — ${escapeHTML(snippet)}`;
  });
  return `${title}\n${lines.join('\n')}`;
}

// ---------- query router (fast paths first) ----------
const STRONGS_RE = /\b[HG]\d{3,5}\b/i;

async function getBotResponse(userText) {
  const msg = userText.trim();
  if (!msg) return "Say something and I will try my best 🙂";

  const lc = msg.toLowerCase();

  // Basics
  if (/\b(hi|hello|hey)\b/.test(lc)) return "Hello! What would you like to explore?";
  if (/\bhow are you\b/.test(lc)) return "I am doing well — thanks for asking! How about you?";

  // Strong’s first
  if (STRONGS_RE.test(msg)) {
    const res = await searchKJVStream(msg, { limit: 5 });
    if (res.length) return formatKJV(res, `Results for ${msg}`);
    return `I did not find Strong’s reference ${msg}.`;
  }

  // PDF snippets
  if (/\b(jane|austen|pride|elizabeth|bingley|darcy)\b/.test(lc)) {
    const snip = await getPdfSnippet('pride', 800);
    if (snip) return `From Pride & Prejudice (opening snippet):\n${snip}`;
  }
  if (/\b(jimmie|dale|st\.?\s*james)\b/.test(lc)) {
    const snip = await getPdfSnippet('jimmie', 800);
    if (snip) return `From The Adventures of Jimmie Dale (opening snippet):\n${snip}`;
  }
  if (/\b(speak and write|devlin|perspicuity|precision)\b/.test(lc)) {
    const snip = await getPdfSnippet('devlin', 800);
    if (snip) return `From How to Speak and Write Correctly (opening snippet):\n${snip}`;
  }

  // Entity-guided KJV search
  const doc = nlp(lc);
  const people = doc.people().out('array');
  const places = doc.places().out('array');
  const dates  = doc.match('#Date').out('array');

  if (people.length) {
    const name = people[0];
    const res = await searchKJVStream(name, { limit: 5 });
    if (res.length) return formatKJV(res, `Mentions related to “${name}”`);
  }
  if (places.length) {
    const place = places[0];
    const res = await searchKJVStream(place, { limit: 5 });
    if (res.length) return formatKJV(res, `Mentions of “${place}”`);
  }
  if (dates.length) {
    const dateq = dates[0];
    const res = await searchKJVStream(dateq, { limit: 5 });
    if (res.length) return formatKJV(res, `References related to “${dateq}”`);
  }

  // General KJV search
  const res = await searchKJVStream(msg, { limit: 5 });
  if (res.length) return formatKJV(res, `Here is what I found:`);

  // Sentiment fallback
  const sent = getSentiment(msg);
  if (sent === 'positive') return "Love the energy — want to explore a text or a topic?";
  if (sent === 'negative') return "Sorry it feels rough — want to switch topics or look something up?";
  return "I did not find a good match yet. Try a Strong’s ID (e.g., H7225), a phrase in quotes, or name a work (e.g., Jimmie Dale).";
}

// ---------- UI handling ----------
let pending = false;
function setBusy(b) {
  pending = b;
  sendBtn.disabled = b;
  input.disabled = b;
}

form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const text = input.value.trim();
  if (!text || pending) return;

  addMsg('You', text);
  input.value = '';
  setBusy(true);
  try {
    const reply = await getBotResponse(text);
    addMsg(bot, reply);
  } catch (err) {
    log(`ERR: ${err?.message || err}`);
    addMsg(bot, "Something hiccuped during search. Try a simpler query or another keyword.");
  } finally {
    setBusy(false); // <-- ensures the input/button “flush” after each request
  }
});
